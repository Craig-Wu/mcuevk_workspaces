#include "arm_2d.h"
#include "arm_2d_disp_adapter_0.h"
#include "console.h"
#include "hal_data.h"

#include "lcd/lcd.h"
#include "perf_counter/perf_counter.h"
#include "utils/log.h"

#if (1 == BSP_MULTICORE_PROJECT) && BSP_TZ_SECURE_BUILD
bsp_ipc_semaphore_handle_t g_core_start_semaphore =
{
    .semaphore_num = 0
};
#endif

static LCD_Device s_lcd;
static uint8_t s_event;
static uint32_t s_cnt;

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
	/* TODO: add your own code here */
#if CONSOLE_CFG_USE_LCD == 0
	/* If using LCD as console output, console should be initialed after arm2d and disp init */
	CONSOLE_Init();
#else
	R_SCI_B_UART_Open(g_uart9.p_ctrl, g_uart9.p_cfg);
#endif
	LOG_Reset();
	perfc_init(false);
	R_GPT_Open(g_timer0.p_ctrl, g_timer0.p_cfg);
	R_GPT_Start(g_timer0.p_ctrl);

	s_lcd.orientation = SCREEN_ORIENTATION_VERTICAL;
	LCD_Init(&s_lcd);

	arm_2d_init();
	disp_adapter0_init();
#if CONSOLE_CFG_USE_LCD
	CONSOLE_Init();
	arm_2d_scene_player_set_switching_mode(&DISP0_ADAPTER, ARM_2D_SCENE_SWITCH_MODE_FADE_WHITE);
	arm_2d_scene_player_switch_to_next_scene(&DISP0_ADAPTER);
#endif

	/* Wake up 2nd core if this is first core and we are inside a multicore project. */
#if (0 == _RA_CORE) && (1 == BSP_MULTICORE_PROJECT) && !BSP_TZ_NONSECURE_BUILD

#if BSP_TZ_SECURE_BUILD
    /* Take semaphore so 2nd core can clear it */
    R_BSP_IpcSemaphoreTake(&g_core_start_semaphore);
#endif

    R_BSP_SecondaryCoreStart();

#if BSP_TZ_SECURE_BUILD
    /* Wait for 2nd core to start and clear semaphore */
    while(FSP_ERR_IN_USE == R_BSP_IpcSemaphoreTake(&g_core_start_semaphore))
    {
        ;
    }
#endif
#endif

#if (1 == _RA_CORE) && (1 == BSP_MULTICORE_PROJECT) && BSP_TZ_SECURE_BUILD
    /* Signal to 1st core that 2nd core has started */
    R_BSP_IpcSemaphoreGive(&g_core_start_semaphore);
#endif

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif

    while (1) {
    	disp_adapter0_task();
    	if (s_event) {
    		s_event = 0;
    		if ((s_cnt % 10) == 0) {
    			printf("\r\nYou can directly print string to LCD with printf()\r\n\r\n");
    		}
    		printf("Current cnt: %u\r\n", s_cnt);
    		s_cnt++;
    	}
    }
}

void TIMER0_Callback(timer_callback_args_t * p_args)
{
	bsp_io_level_t level;

	if (p_args->event == TIMER_EVENT_CYCLE_END) {
		R_IOPORT_PinRead(g_ioport.p_ctrl, USER_LED, &level);
		if (level == BSP_IO_LEVEL_HIGH) {
			R_IOPORT_PinWrite(g_ioport.p_ctrl, USER_LED, BSP_IO_LEVEL_LOW);
		}
		else {
			R_IOPORT_PinWrite(g_ioport.p_ctrl, USER_LED, BSP_IO_LEVEL_HIGH);
		}
		s_event = 1;
	}
}

#if LOG_CFG_HAS_STDIO == 0
void LOG_Puts(const char *str)
{
	const char *pch = str;

	while (*pch) {
		g_uart9_ctrl.p_reg->TDR_BY = *pch;
		while ((g_uart9_ctrl.p_reg->CSR & R_SCI_B0_CSR_TDRE_Msk) == 0) {}
		pch++;
	}
}
#endif

#if CONSOLE_CFG_USE_UART == 0
void UART9_Callback(uart_callback_args_t *p_args)
{
	(void)p_args;
}
#endif

#if LOG_CFG_EN_TIMESTAMP
void LOG_GetTime(uint32_t *s, uint32_t *ms)
{
	int64_t t = get_system_ms();
	*s = (uint32_t)(t / 1000);
	*ms = (uint32_t)(t % 1000);
}
#endif

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif

int32_t Disp0_DrawBitmap(int16_t x, int16_t y, int16_t width, int16_t height, const uint8_t *bitmap)
{
	LCD_PortDrawBitmap(&s_lcd, (uint16_t)x, (uint16_t)y, (uint16_t)width, (uint16_t)height, bitmap);

	return 0;
}
