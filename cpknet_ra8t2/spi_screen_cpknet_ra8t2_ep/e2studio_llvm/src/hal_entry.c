#include "console.h"
#include "hal_data.h"
#include "lcd.h"
#include "picture.h"

#include "perf_counter/perf_counter.h"
#include "utils/log.h"

#if (1 == BSP_MULTICORE_PROJECT) && BSP_TZ_SECURE_BUILD
bsp_ipc_semaphore_handle_t g_core_start_semaphore =
{
    .semaphore_num = 0
};
#endif

extern const uint16_t c_bmppicture01RGB565[480*222];

static LCD_Device s_lcd;

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
	/* TODO: add your own code here */
	int i;

	CONSOLE_Init();
	LOG_Reset();
	perfc_init(false);

	s_lcd.orientation = SCREEN_ORIENTATION_VERTICAL;
	LCD_Init(&s_lcd);

	/* Wake up 2nd core if this is first core and we are inside a multicore project. */
#if (0 == _RA_CORE) && (1 == BSP_MULTICORE_PROJECT) && !BSP_TZ_NONSECURE_BUILD

#if BSP_TZ_SECURE_BUILD
    /* Take semaphore so 2nd core can clear it */
    R_BSP_IpcSemaphoreTake(&g_core_start_semaphore);
#endif

    R_BSP_SecondaryCoreStart();

#if BSP_TZ_SECURE_BUILD
    /* Wait for 2nd core to start and clear semaphore */
    while(FSP_ERR_IN_USE == R_BSP_IpcSemaphoreTake(&g_core_start_semaphore))
    {
        ;
    }
#endif
#endif

#if (1 == _RA_CORE) && (1 == BSP_MULTICORE_PROJECT) && BSP_TZ_SECURE_BUILD
    /* Signal to 1st core that 2nd core has started */
    R_BSP_IpcSemaphoreGive(&g_core_start_semaphore);
#endif

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif

    R_BSP_SoftwareDelay(1, BSP_DELAY_UNITS_SECONDS);
    LCD_PortFillRectangle(&s_lcd, 0, 0, 111, 240, 0xF800);
    R_BSP_SoftwareDelay(1, BSP_DELAY_UNITS_SECONDS);
    LCD_PortFillRectangle(&s_lcd, 111, 0, 111, 240, 0x07E0);
    R_BSP_SoftwareDelay(1, BSP_DELAY_UNITS_SECONDS);
    LCD_PortFillRectangle(&s_lcd, 0, 240, 111, 240, 0x001F);
    R_BSP_SoftwareDelay(1, BSP_DELAY_UNITS_SECONDS);
    LCD_PortFillRectangle(&s_lcd, 111, 240, 111, 240, 0xFDA0);
    R_BSP_SoftwareDelay(1, BSP_DELAY_UNITS_SECONDS);

    LCD_PortDrawBitmap(&s_lcd, 0, 0, 222, 480, (const uint8_t *)g_picture01.pixel_data);
    while (1) {
    	for (i = 0; i < 5; i++) {
			R_IOPORT_PinWrite(g_ioport.p_ctrl, USER_LED, BSP_IO_LEVEL_HIGH);
			R_BSP_SoftwareDelay(500, BSP_DELAY_UNITS_MILLISECONDS);
			R_IOPORT_PinWrite(g_ioport.p_ctrl, USER_LED, BSP_IO_LEVEL_LOW);
			R_BSP_SoftwareDelay(500, BSP_DELAY_UNITS_MILLISECONDS);
    	}
    	LCD_PortDrawBitmap(&s_lcd, 0, 0, 222, 480, (const uint8_t *)g_picture02.pixel_data);

    	for (i = 0; i < 5; i++) {
			R_IOPORT_PinWrite(g_ioport.p_ctrl, USER_LED, BSP_IO_LEVEL_HIGH);
			R_BSP_SoftwareDelay(500, BSP_DELAY_UNITS_MILLISECONDS);
			R_IOPORT_PinWrite(g_ioport.p_ctrl, USER_LED, BSP_IO_LEVEL_LOW);
			R_BSP_SoftwareDelay(500, BSP_DELAY_UNITS_MILLISECONDS);
    	}
    	LCD_PortDrawBitmap(&s_lcd, 0, 0, 222, 480, (const uint8_t *)g_picture01.pixel_data);
    }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif

#if LOG_CFG_EN_TIMESTAMP
void LOG_GetTime(uint32_t *s, uint32_t *ms)
{
	int64_t t = get_system_ms();
	*s = (uint32_t)(t / 1000);
	*ms = (uint32_t)(t % 1000);
}
#endif
