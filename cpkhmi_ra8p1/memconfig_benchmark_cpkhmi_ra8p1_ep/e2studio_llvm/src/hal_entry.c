#include "console.h"
#include "hal_data.h"
#include "hal_entry.h"

#include "coremark/coremark.h"
#include "perf_counter/perf_counter.h"

#if (1 == BSP_MULTICORE_PROJECT) && BSP_TZ_SECURE_BUILD
bsp_ipc_semaphore_handle_t g_core_start_semaphore =
{
    .semaphore_num = 0
};
#endif

#if __DATA_AREA == 1
static uint8_t s_dtcm_stack[BSP_CFG_STACK_MAIN_BYTES] DATA_AREA_BSS __attribute__((aligned(8)));
static uint32_t *s_stack_top = (uint32_t *)(s_dtcm_stack + BSP_CFG_STACK_MAIN_BYTES);
#endif

DATA_AREA_DATA static core_param s_core_param;

DATA_AREA_DATA static int s_loop_num;
CODE_AREA void foo(void)
{
	while (s_loop_num--) {
		__asm__ volatile (
			"NOP"
		);
	}
}

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
	/* TODO: add your own code here */
#if __DATA_AREA == 1
	__set_MSPLIM((uint32_t)s_dtcm_stack);
	__asm__ volatile (
		"mov sp, %[top]"
		:
		: [top] "r" (s_stack_top)
		: "sp"
	);
#endif
	CONSOLE_Init();
	perfc_init(false);

	printf("Input any character to start coremark\r\n");
	while (1) {
		R_BSP_SoftwareDelay(2, BSP_DELAY_UNITS_SECONDS);
		if (CONSOLE_HasData()) {
			break;
		}
		else {
			printf("Input any character to start coremark\r\n");
		}
	}
	printf("foo() running, please wait...\r\n");
	int64_t time_start = get_system_us();
	__cpu_perf__("foo") {
		// coremark_main(&s_core_param);
		s_loop_num = 100000000;
		foo();
	};
	int64_t time_end = get_system_us();
	// coremark_report(&s_core_param);
	printf("\r\nfoo() spend time: %lld us\r\n", time_end - time_start);

	while (1) {
		R_IOPORT_PinWrite(g_ioport.p_ctrl, USER_LED, BSP_IO_LEVEL_HIGH);
		R_BSP_SoftwareDelay(500, BSP_DELAY_UNITS_MILLISECONDS);
		R_IOPORT_PinWrite(g_ioport.p_ctrl, USER_LED, BSP_IO_LEVEL_LOW);
		R_BSP_SoftwareDelay(500, BSP_DELAY_UNITS_MILLISECONDS);
	}

	/* Wake up 2nd core if this is first core and we are inside a multicore project. */
#if (0 == _RA_CORE) && (1 == BSP_MULTICORE_PROJECT) && !BSP_TZ_NONSECURE_BUILD

#if BSP_TZ_SECURE_BUILD
    /* Take semaphore so 2nd core can clear it */
    R_BSP_IpcSemaphoreTake(&g_core_start_semaphore);
#endif

    R_BSP_SecondaryCoreStart();

#if BSP_TZ_SECURE_BUILD
    /* Wait for 2nd core to start and clear semaphore */
    while(FSP_ERR_IN_USE == R_BSP_IpcSemaphoreTake(&g_core_start_semaphore))
    {
        ;
    }
#endif
#endif

#if (1 == _RA_CORE) && (1 == BSP_MULTICORE_PROJECT) && BSP_TZ_SECURE_BUILD
    /* Signal to 1st core that 2nd core has started */
    R_BSP_IpcSemaphoreGive(&g_core_start_semaphore);
#endif

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif
