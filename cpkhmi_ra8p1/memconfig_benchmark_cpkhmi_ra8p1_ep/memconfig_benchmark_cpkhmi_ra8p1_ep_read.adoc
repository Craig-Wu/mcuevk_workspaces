:imagesdir: images

RA8P1 有多个内存区域可以存放代码和数据，并支持指令缓存和数据缓存。该工程以 coremark 为基准，通过将代码和数据放在不同区域、缓存是否开启来演示不同内存区域配置和缓存配置对性能的影响。

== 切换配置

示例工程有两个编译配置，分别为 Debug 和 Release，可以按下图所示切换，二者的区别：

* Debug 配置可以调试，Release 没有调试符号，在 Release 配置下可以使用 JFlash Lite 或 RFP 等其它烧录工具进行烧录
* Debug 使用 RTT View 输入输出，Release 使用 UART 输入输出，UART 波特率 2000000，8bit 数据位，1bit 停止位，无奇偶校验

image::Snipaste_2026-01-09_10-41-17_01.png[role="thumb", width=800]

=== 预定义宏选项

示例工程可以使用下图中红色方框中的预定义宏来决定代码和变量存储位置以及 Cache 功能。

[.text-center]
--
image::Snipaste_2026-01-19_13-43-05.png[role="thumb"]
--

* __CODE_AREA: 决定 `CODE_AREA` 的值，控制代码存储的位置
** `__CODE_AREA=CODE_MRAM` 或未定义: 被 `CODE_AREA` 修饰的函数存储在 MRAM（编译器默认行为）
** `__CODE_AREA=CODE_ITCM`: 被 `CODE_AREA` 修饰的函数存储在 ITCM
* __DATA_AREA 选项: 决定 `DATA_AREA_BSS`、`DATA_AREA_DATA`、`DATA_AREA_ZERO` 的值，控制变量存储的位置
** `__DATA_AREA=DATA_SRAM` 或未定义: 被以上宏修饰的变量存储在 SRAM（编译器默认行为）
** `__DATA_AREA=DATA_DTCM`: 被以上宏修饰的变量存储在 DTCM
* BSP_CFG_DCACHE_ENABLED: 决定是否开启 DCache 功能
** `BSP_CFG_DCACHE_ENABLED=1`: 开启 DCache
** `BSP_CFG_DCACHE_ENABLED=0`: 关闭 DCache
** 未定义: 由 FSP Configuration 决定
* BSP_CFG_DCACHE_FORCE_WRITETHROUGH: 决定 DCache 模式，必须要开启 DCache，该配置才起效
** `BSP_CFG_DCACHE_FORCE_WRITETHROUGH=1`: DCache 工作在 Write Through 模式
** `BSP_CFG_DCACHE_FORCE_WRITETHROUGH=0`: DCache 工作在 Write Back 模式
** 未定义: 由 FSP Configuration 决定

下面是在上图所示配置下的运行结果

image::Snipaste_2026-01-19_13-32-43.png[role="thumb"]

== 测量其它代码运行时间

应用程序入口在 hal_entey.c 中的 `hal_entey()` 函数，示例工程的函数主要内容如下：

[source,c,subs="verbatim,attributes"]
----
printf("Input any character to start coremark\r\n");
while (1) {
    R_BSP_SoftwareDelay(2, BSP_DELAY_UNITS_SECONDS);
    if (CONSOLE_HasData()) {
        break;
    }
    else {
        printf("Input any character to start coremark\r\n");
    }
}
printf("Coremark running, please wait...\r\n");
__cpu_perf__("Coremark") {
    coremark_main(&s_core_param);
};
coremark_report(&s_core_param);
----

要测量其它代码，只需将要测量部分放进 `+__cpu_perf__+` 的花括号内。例如，假设要测量如下一个函数的运行时间

[source,c,subs="verbatim,attributes"]
----
DATA_AREA_DATA static int s_loop_num;
CODE_AREA void foo(void)
{
	while (s_loop_num--) {
		__asm__ volatile (
			"NOP"
		);
	}
}
----

那么对 hal_entry() 做如下修改

[source,c,subs="verbatim,attributes"]
----
printf("Input any character to start coremark\r\n");
while (1) {
    R_BSP_SoftwareDelay(2, BSP_DELAY_UNITS_SECONDS);
    if (CONSOLE_HasData()) {
        break;
    }
    else {
        printf("Input any character to start coremark\r\n");
    }
}
printf("foo() running, please wait...\r\n");
int64_t time_start = get_system_us();
__cpu_perf__("foo") {
    // coremark_main(&s_core_param);
    s_loop_num = 100000000;
    foo();
};
int64_t time_end = get_system_us();
// coremark_report(&s_core_param);
printf("\r\nfoo() spend time: %lld\r\n", time_end - time_start);
----

运行结果如下：

image::Snipaste_2026-01-16_15-31-05.png[role="thumb"]
