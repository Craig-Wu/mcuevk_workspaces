:imagesdir: images

== 简介

此样例工程集成了perf_counter性能测试工具，并通过运行CoreMark®程序来测试不同编译器和编译配置下，RA8P1的Cortex M85内核的性能，该性能数据可以作为编译器和编译参数选择的一个参考。

CoreMark测试并不支持CM85内核的Helium指令和RA8P1集成的Ethos U55 NPU，仅提供CPU标量运算性能的参考。

本样例程序CoreMark的测试代码运行在I-TCM中，数据使用D-TCM，最大限度排除了片内存储器和总线对测试结果的影响。

样例程序包含三个目录，对应FSP 6.3.0可以支持的三种编译器和对应的集成开发环境

* e^2^studio 2025-12 + LLVM 21.1.1
* e^2^studio 2025-12 + GCC 13.2.1
* Keil MDK 5.42 + ARM Compiler 6.23 (通过RASC生成MDK工程)

本工程也可作为一个基础测试框架，对用户程序进行性能测试。有关如何设置工程并加入用户代码进行测试，请参以下文档：
link:perf_counter_addusercode_e2.adoc[e^2^studio - 基于perf_counter工程进行用户代码性能测试]
link:perf_counter_addusercode_mdk.adoc[Keil MDK - 基于perf_counter工程进行用户代码性能测试]


== 快速查看测试结果

在 `perf_counter_cpkhmi_ra8p1_ep` 文件夹下已提供三个编译好的 hex 文件，分别对应三种环境，可以用瑞萨的RFP烧录工具或Segger的J-Flash Lite烧录后运行。其中使用 e^2^studio 开发环境的工程均使用 Release 配置编译生成，性能表现均会优于 Debug 配置。

* perf_counter_llvm_release.hex: e^2^studio + llvm 21.1.1
* perf_counter_gcc_release.hex: e^2^studio + arm-none-eabi-gcc 13.2.1.arm-13-7
* perf_counter_keil.hex: Keil MDK + ARMCC6.23

Release配置下

* 测试结果使用 UART 输出，使用RA8P1的SCI9，连接J-Link OB的虚拟串口
* PC端选择J-Link串口，设置波特率 2000000，8bit 数据位，1bit 停止位，无奇偶校验。
* 输出信息使用UTF-8编码，其中含有中文字符，建议使用支持 UTF-8 编码的串口终端工具，例如 Putty。
* 输出结果中包含了由perf_counter工具统计的运行CPU周期数。

各个编译器使用的优化级别和CoreMark结果见下表：


.展开查看perf_counter_llvm_release.hex 运行结果
[%collapsible]
====
image::Snipaste_2026-01-08_17-03-43.png[align="center", width=640, height=480]
====

.展开查看perf_counter_gcc_release.hex 运行结果
[%collapsible]
====
image::Snipaste_2026-01-09_09-59-22.png[align="center", width=640, height=480]
====

.展开查看perf_counter_keil.hex 运行结果
[%collapsible]
====
image::Snipaste_2026-01-08_17-10-10.png[align="center", width=640, height=480]
====

== 在Release配置下修改编译优化选项

perf_counter_cpkhmi_ra8p1_ep 目录下三个工程文件夹对应各个编译优化选项的CoreMark测试结果如下：

如果您有兴趣自己复现一下测试结果，请按下面的流程修改编译优化选项。

=== e^2^studio + llvm 或 gcc

其中 e2studio_gcc 和 e2studio_llvm 都是使用 e2 studio 进行管理和构建的，只是使用的编译器不同。有关工程的配置都一样，因此只以 e2studio_llvm 为例说明如何使用，对于 e2studio_gcc，大部分步骤都一样，只对差异部分做说明。

==== 导入工程并通过FSP生成工程文件

导入后先双击工程目录下的 configuration.xml 打开 FSP Configuration，这里不需要对里面的配置做任何改动，直接点击右上角的 `Generate Project Content` 生成工程文件即可

image::Snipaste_2026-01-09_10-35-03.png[]

==== LLVM编译器修改优化选项

在工程的 C/C++ 属性设置界面中的 Optimization 选项，通过 Optimization Level 选择优化级别。

image::Snipaste_2026-01-13_10-06-36.png[]

对于 LLVM 编译器，还有一个链接时优化选项可选，该选项也在 Optimization 中，若要使用，勾选 Link-time optimizer(-flto) 选项即可

image::Snipaste_2026-01-13_10-09-09.png[]

==== GCC编译器修改优化选项

在工程的 C/C++ 属性设置界面中的 Optimization 选项，通过 Optimization Level 选择优化级别。

image::Snipaste_2026-01-13_10-12-14.png[]

==== 构建工程并烧录镜像文件

点击 e^2^studio 左上角的锤子图标构建工程。下方控制台会输出编译信息。

Release配置缺省不连接调试器进行调试，可以通过写入功能，将编译好的程序烧录到片内存储器。

=== Keil MDK + ac6

==== RASC 打开工程

MDK 工程需要先使用 RASC 生成。打开 RASC，点击左上角的 `File` -> `Open`，然后选择到工程目录下的 `configuration.xml`

image::Snipaste_2026-01-09_13-36-36.png[]

之后会进入以下界面，在该界面无需任何配置，直接点击右上角的 `Generate Project Content` 即可

image::Snipaste_2026-01-09_13-40-02.png[]

==== 修改编译优化选项

编译选项在 `via/rasc_armclang.via` 和 `via/rasc_armlink.via` 中修改，*在 keil 里选择是无效的，这两个文件的优先级高于 keil 里的设置*。并且要注意，每次使用 RASC 生成，这两个文件都会被覆盖，因此需要注意这两个文件的修改是否被 RASC 覆盖。如下图，为 RASC 生成后的默认选项

image::Snipaste_2026-01-09_14-55-25.png[]

要获得最高运行速度，可以将优化选项改为 `-Omax`，链接选项中添加 `--lto` 获得最高的优化等级

image::Snipaste_2026-01-09_14-56-35.png[]

==== 构建工程

点击左上角的符号进行构建

image::Snipaste_2026-01-09_13-47-31.png[]

==== 写入 hex 文件并运行

随后点击调试符号进行调试

image::Snipaste_2026-01-09_13-50-19.png[align="center"]

进入调试界面，点击红色框中的运行让程序自由运行

image::Snipaste_2026-01-09_13-58-41.png[]

== 添加用户程序进行性能测试

需要使用本工程框架对用户程序进行性能测试时，对工程配置进行一定的修改，例如

* 切换Debug配置，确保用户程序可以正确运行
* 使用perf_counter进行所需的的性能测试，并添加输入输出
* 切换Release配置，测试能获得的最高性能（或其他结果）

样例设置请参以下文档：
link:perf_counter_addusercode_e2.adoc[e^2^studio - 基于perf_counter工程进行用户代码性能测试]
link:perf_counter_addusercode_mdk.adoc[Keil MDK - 基于perf_counter工程进行用户代码性能测试]

== perf_counter 的使用指南

perf_counter完整的说明可以参考link:https://github.com/GorgonMeducer/perf_counter[Github]代码库的文档，中文资料请参考作者的微信公众号文章 link:https://mp.weixin.qq.com/s/pSjphzHc79xaGylzS1dL8g[超级嵌入式系统“性能/时间”工具箱]。

本例程主要使用以下功能

* 调用 `perfc_init(false);` 初始化
* `get_system_ms()`、`get_system_us()` 获取自初始化后经过的时间
* `get_system_ticks()` 获取自初始化后经过的 CPU 周期数
* `+__cycleof__()+` 统计周期数。例如，统计延时函数使用的完整 CPU 周期

[source,c,subs="verbatim,attributes"]
----
int64_t s = get_system_ms();
__cycleof__("100MS") {
    R_BSP_SoftwareDelay(100, BSP_DELAY_UNITS_MILLISECONDS);
}
int64_t e = get_system_ms();
printf("Using time: %lld ms", e - s);
----

输出结果类似下面这样

image::Snipaste_2026-01-13_11-20-19.png[]

* `+__cpu_perf__()+` 统计周期数+DCache Miss-Rate。但仅限使用 PMU 时可用。例如，统计 coremark 运行时时间和 DCache Miss-Rate

[source,c,subs="verbatim,attributes"]
----
__cpu_perf__("Coremark") {
    coremark_main();
};
----

perf_counter 的输出结果类似下面这样

image::Snipaste_2026-01-13_11-26-43.png[align="center"]
