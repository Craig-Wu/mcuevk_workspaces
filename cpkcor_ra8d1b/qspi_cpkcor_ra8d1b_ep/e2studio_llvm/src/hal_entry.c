/*
* Copyright (c) 2020 - 2024 Renesas Electronics Corporation and/or its affiliates
*
* SPDX-License-Identifier: BSD-3-Clause
*/

#include "hal_data.h"

#define LED1_ON     R_PORT4->PCNTR3_b.POSR = (1 << 9)  // LED_LD9  On,  High
#define LED1_OFF    R_PORT4->PCNTR3_b.PORR = (1 << 9)  // LED_LD9  Off, Low
#define LED2_ON     R_PORT4->PCNTR3_b.POSR = (1 << 10) // LED_LD10 On,  High
#define LED2_OFF    R_PORT4->PCNTR3_b.PORR = (1 << 10) // LED_LD10 Off, Low
#define LED3_ON     R_PORT4->PCNTR3_b.POSR = (1 << 11) // LED_LD11 On,  High
#define LED3_OFF    R_PORT4->PCNTR3_b.PORR = (1 << 11) // LED_LD11 Off, Low
#define LED4_ON     R_PORT4->PCNTR3_b.POSR = (1 << 12) // LED_LD12 On,  High
#define LED4_OFF    R_PORT4->PCNTR3_b.PORR = (1 << 12) // LED_LD12 Off, Low

uint8_t test_data[256];
uint8_t Flash_Type = 0;
#define AT25SF128A    (1)
#define W25Q128JVPIQ  (2)
#define W25Q128JW     (3)

void fsp_assert(fsp_err_t err);
void ospi_test_wait_until_wip(void);

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */
    fsp_err_t err = FSP_SUCCESS;
    spi_flash_direct_transfer_t direct_command;
    FSP_CRITICAL_SECTION_DEFINE;

    uint8_t *dest = (uint8_t*) 0x90000000U;
    for (uint32_t i = 0; i < sizeof(test_data); i++)
    {
        test_data[i] = (uint8_t) i;
    }

    err = R_OSPI_B_Open (g_ospi0.p_ctrl, g_ospi0.p_cfg);
    fsp_assert (err);

    R_XSPI->LIOCFGCS_b[1].SDRSMPMD = 0x1;

    /* Enable Reset */
    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0x66;
    direct_command.command_length = 0x1;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    fsp_assert (err);

    /* Reset Device */
    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0x99;
    direct_command.command_length = 0x1;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    fsp_assert (err);

    R_BSP_SoftwareDelay(30, BSP_DELAY_UNITS_MICROSECONDS);

    /* Check Manufacture/Device ID via 1S-1S-1S protocol */
    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0x90;
    direct_command.command_length = 0x1;
    direct_command.address        = 0x0000;//0x000000;
    direct_command.address_length = 0x2;//0x3;
    direct_command.dummy_cycles   = 0x8;//0;
    direct_command.data_length    = 0x2;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);
    fsp_assert (err);

    if((direct_command.data == 0xEF17) || (direct_command.data == 0x17EF))//For CPKCOR W25Q128JVPIQ
    {
        Flash_Type = W25Q128JVPIQ;
    }
    else if((direct_command.data == 0x1F17) || (direct_command.data == 0x171F))//For CPKCOR AT25SF128A
    {
        Flash_Type = AT25SF128A;
    }
    else if((direct_command.data == 0xEF18) || (direct_command.data == 0x18EF))//For CPKDIS W25Q128JW
    {
        Flash_Type = W25Q128JW;
    }
    else
    {
        __BKPT(0);
    }

    /* Set Write Enable via 1S-1S-1S protocol */
    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0x06;
    direct_command.command_length = 0x1;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    fsp_assert (err);
    ospi_test_wait_until_wip();

    /* Erase sector 0x0 via 1S-1S-1S protocol */
    err = R_OSPI_B_Erase (g_ospi0.p_ctrl, dest, 0x1000);
    fsp_assert (err);
    ospi_test_wait_until_wip ();

    /* Set Write Enable via 1S-1S-1S protocol */
    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0x06;
    direct_command.command_length = 0x1;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
    fsp_assert (err);
    ospi_test_wait_until_wip();

#if 1
    dest = (uint8_t*) 0x90000000U;
    for (uint32_t i = 0; i < (sizeof(test_data) / 64); i++)
    {
        FSP_CRITICAL_SECTION_ENTER;

        err = R_OSPI_B_Write (g_ospi0.p_ctrl, &test_data[64 * i], dest + 64 * i, 64);

        FSP_CRITICAL_SECTION_EXIT;
        fsp_assert (err);

        ospi_test_wait_until_wip();
    }

#if BSP_CFG_DCACHE_ENABLED
    SCB_InvalidateDCache_by_Addr((volatile void *)0x90000000, 256);
#endif

    for (uint32_t i = 0; i < sizeof(test_data); i++)
    {
        uint8_t data = *(dest + i);
        if (test_data[i] != data)
        {
            fsp_assert (FSP_ERR_ASSERTION);
        }
    }
#endif
#if 1
    dest = (uint8_t*) 0x90040000U;
    for (uint32_t i = 0; i < (sizeof(test_data) / 64); i++)
    {
        FSP_CRITICAL_SECTION_ENTER;

        err = R_OSPI_B_Write (g_ospi0.p_ctrl, &test_data[64 * i], dest + 64 * i, 64);

        FSP_CRITICAL_SECTION_EXIT;
        fsp_assert (err);

        ospi_test_wait_until_wip();
    }

#if BSP_CFG_DCACHE_ENABLED
    SCB_InvalidateDCache_by_Addr((volatile void *)0x90040000, 256);
#endif

    for (uint32_t i = 0; i < sizeof(test_data); i++)
    {
        uint8_t data = *(dest + i);
        if (test_data[i] != data)
        {
            fsp_assert (FSP_ERR_ASSERTION);
        }
    }
#endif

    //For CPKCOR AT25SF128A
    if (AT25SF128A == Flash_Type)
    {
        /* Read Status Register Byte 2 */
        memset(&direct_command, 0, sizeof(direct_command));
        direct_command.command        = 0x35;
        direct_command.command_length = 0x1;
        direct_command.address        = 0x0;
        direct_command.address_length = 0x0;
        direct_command.dummy_cycles   = 0x0;
        direct_command.data_length    = 0x1;
        err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);
        fsp_assert (err);

        /* Set Write Enable for Volatile Status Register via 1S-1S-1S protocol */
        memset(&direct_command, 0, sizeof(direct_command));
        direct_command.command        = 0x50;
        direct_command.command_length = 0x1;
        err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
        fsp_assert (err);
        ospi_test_wait_until_wip();

        /* Set QE bit to 1 to enable Quad */
        memset(&direct_command, 0, sizeof(direct_command));
        direct_command.command        = 0x31;
        direct_command.command_length = 0x1;
        direct_command.data           = 0x02;
        direct_command.data_length    = 0x1;
        err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_WRITE);
        fsp_assert (err);

        /* Read Status Register Byte 2 */
        memset(&direct_command, 0, sizeof(direct_command));
        direct_command.command        = 0x35;
        direct_command.command_length = 0x1;
        direct_command.address        = 0x0000;
        direct_command.address_length = 0x0;
        direct_command.dummy_cycles   = 0x0;
        direct_command.data_length    = 0x1;
        err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);
    }

    err = R_OSPI_B_SpiProtocolSet(g_ospi0.p_ctrl, SPI_FLASH_PROTOCOL_1S_4S_4S);
    fsp_assert (err);

    /* Check Manufacture/Device ID via 1S-4S-4S protocol */
    memset(&direct_command, 0, sizeof(direct_command));
    direct_command.command        = 0x94;
    direct_command.command_length = 0x1;
    direct_command.address        = 0x000000;
    direct_command.address_length = 0x3;
    direct_command.dummy_cycles   = 0x6;
    direct_command.data_length    = 0x2;
    err = R_OSPI_B_DirectTransfer (g_ospi0.p_ctrl, &direct_command, SPI_FLASH_DIRECT_TRANSFER_DIR_READ);
    fsp_assert (err);
    //if(!((direct_command.data == 0xEF17) || (direct_command.data == 0x17EF)))//For CPKCOR W25Q128JVPIQ
    if(!((direct_command.data == 0x1F17) || (direct_command.data == 0x171F)))//For CPKCOR AT25SF128A
    {
        __BKPT(0);
    }

#if 1
#if BSP_CFG_DCACHE_ENABLED
    SCB_InvalidateDCache_by_Addr((volatile void *)0x90000000, 256);
#endif
    dest = (uint8_t*) 0x90000000U;
    for (uint32_t i = 0; i < sizeof(test_data); i++)
    {
        uint8_t data = *(dest + i);
        if (test_data[i] != data)
        {
            fsp_assert (FSP_ERR_ASSERTION);
        }
    }
#endif

#if 1
#if BSP_CFG_DCACHE_ENABLED
    SCB_InvalidateDCache_by_Addr((volatile void *)0x90040000, 256);
#endif
    dest = (uint8_t*) 0x90040000U;
    for (uint32_t i = 0; i < sizeof(test_data); i++)
    {
        uint8_t data = *(dest + i);
        if (test_data[i] != data)
        {
            fsp_assert (FSP_ERR_ASSERTION);
        }
    }
#endif

    // happy path
    __BKPT(0);

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

void fsp_assert(fsp_err_t err)
{
    if (FSP_SUCCESS != err)
    {
        LED3_ON;
        __BKPT(0);
    }
}

/*******************************************************************************************************************//**
 * Wait until work in progress bit is cleared
 **********************************************************************************************************************/
void ospi_test_wait_until_wip(void)
{
    spi_flash_status_t status;
    status.write_in_progress = true;
    uint32_t timeout = UINT32_MAX;
    while ((status.write_in_progress) && (--timeout > 0))
    {
        fsp_assert (R_OSPI_B_StatusGet (g_ospi0.p_ctrl, &status));
    }

    if (0 == timeout)
    {
        fsp_assert (FSP_ERR_TIMEOUT);
    }
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, &IOPORT_CFG_NAME);
    }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif
